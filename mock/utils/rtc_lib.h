#pragma once
#include "mcu/mcu.h"
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "math.h"
#include "mcu/timer.h"
#include "crc.h"

namespace utils {

    
    
    
/** Constants */
#define SECONDS_PER_DAY 86400L ///< 60 * 60 * 24
#define SECONDS_FROM_1970_TO_2000                                              \
946684800 ///< Unixtime for 2000-01-01 00:00:00, useful for initialization

/**************************************************************************/
/*!
    *  @brief  Simple general-purpose date/time class (no TZ / DST / leap
    *          seconds).
    * 
    *  This class stores date and time information in a broken-down form, as a
    *  tuple (year, month, day, hour, minute, second). The day of the week is
    *  not stored, but computed on request. The class has no notion of time
    *  zones, daylight saving time, or
    *  [leap seconds](http://en.wikipedia.org/wiki/Leap_second): time is stored
    *  in whatever time zone the user chooses to use.
    * 
    *  The class supports dates in the range from 1 Jan 2000 to 31 Dec 2099
    *  inclusive.
    */
/**************************************************************************/

class DateTime {
public:
    DateTime(uint32_t t = SECONDS_FROM_1970_TO_2000);
    DateTime(uint16_t year, uint8_t month, uint8_t day,
            uint8_t hour = 0, uint8_t min = 0, uint8_t sec = 0);
    DateTime(const DateTime &copy);
    DateTime(const char *date, const char *time);
    // DateTime(const __FlashStringHelper *date, const __FlashStringHelper *time);
    DateTime(const char *iso8601date);
    bool isValid() const;
    char *toString(char *buffer);
    
    /*!
        *    @brief  Return the year.
        *    @return Year (range: 2000--2099).
        */
    uint16_t year() const { return 2000U + yOff; }
    /*!
        *    @brief  Return the month.
        *    @return Month number (1--12).
        */
    uint8_t month() const { return m; }
    /*!
        *    @brief  Return the day of the month.
        *    @return Day of the month (1--31).
        */
    uint8_t day() const { return d; }
    /*!
        *    @brief  Return the hour
        *    @return Hour (0--23).
        */
    uint8_t hour() const { return hh; }
    
    uint8_t twelveHour() const;
    /*!
        *    @brief  Return whether the time is PM.
        *    @return 0 if the time is AM, 1 if it's PM.
        */
    uint8_t isPM() const { return hh >= 12; }
    /*!
        *    @brief  Return the minute.
        *    @return Minute (0--59).
        */
    uint8_t minute() const { return mm; }
    /*!
        *    @brief  Return the second.
        *    @return Second (0--59).
        */
    uint8_t second() const { return ss; }
    
    uint8_t dayOfTheWeek() const;
    
    /* 32-bit times as seconds since 2000-01-01. */
    uint32_t secondstime() const;
    
    /* 32-bit times as seconds since 1970-01-01. */
    uint32_t unixtime(void) const;
    
    /*!
        *    Format of the ISO 8601 timestamp generated by `timestamp()`. Each
        *    option corresponds to a `toString()` format as follows:
        */
    enum timestampOpt {
        TIMESTAMP_FULL, //!< `YYYY-MM-DDThh:mm:ss`
        TIMESTAMP_TIME, //!< `hh:mm:ss`
        TIMESTAMP_DATE  //!< `YYYY-MM-DD`
    };
    void timestamp(char *buffer25, timestampOpt opt = TIMESTAMP_FULL);
    

    bool operator<(const DateTime &right) const;
    
    /*!
        *    @brief  Test if one DateTime is greater (later) than another.
        *    @warning if one or both DateTime objects are invalid, returned value is
        *      meaningless
        *    @see use `isValid()` method to check if DateTime object is valid
        *    @param right DateTime object to compare
        *    @return True if the left DateTime is later than the right one,
        *      false otherwise
        */
    bool operator>(const DateTime &right) const { return right < *this; }
    
    /*!
        *    @brief  Test if one DateTime is less (earlier) than or equal to another
        *    @warning if one or both DateTime objects are invalid, returned value is
        *      meaningless
        *    @see use `isValid()` method to check if DateTime object is valid
        *    @param right DateTime object to compare
        *    @return True if the left DateTime is earlier than or equal to the
        *      right one, false otherwise
        */
    bool operator<=(const DateTime &right) const { return !(*this > right); }
    
    /*!
        *    @brief  Test if one DateTime is greater (later) than or equal to another
        *    @warning if one or both DateTime objects are invalid, returned value is
        *      meaningless
        *    @see use `isValid()` method to check if DateTime object is valid
        *    @param right DateTime object to compare
        *    @return True if the left DateTime is later than or equal to the right
        *      one, false otherwise
        */
    bool operator>=(const DateTime &right) const { return !(*this < right); }
    bool operator==(const DateTime &right) const;
    
    /*!
        *    @brief  Test if two DateTime objects are not equal.
        *    @warning if one or both DateTime objects are invalid, returned value is
        *      meaningless
        *    @see use `isValid()` method to check if DateTime object is valid
        *    @param right DateTime object to compare
        *    @return True if the two objects are not equal, false if they are
        */
    bool operator!=(const DateTime &right) const { return !(*this == right); }
    
protected:
    uint8_t yOff; ///< Year offset from 2000
    uint8_t m;    ///< Month 1-12
    uint8_t d;    ///< Day 1-31
    uint8_t hh;   ///< Hours 0-23
    uint8_t mm;   ///< Minutes 0-59
    uint8_t ss;   ///< Seconds 0-59
};




    
    
    
    
    
    
    
    
    /*
class DateTime {
public:
    DateTime (uint32_t t =0);
    DateTime (uint16_t year, uint8_t month, uint8_t day, uint8_t hour =0, uint8_t min =0, uint8_t sec =0);
    DateTime (const char* date, const char* time);
    uint16_t year() const       { return 2000 + yOff; }
    uint8_t  month() const       { return m; }
    uint8_t  day() const         { return d; }
    uint8_t  hour() const        { return hh; }
    uint8_t  minute() const      { return mm; }
    uint8_t  second() const      { return ss; }
    uint32_t secondstime() const; // 32-bit times as seconds since 1/1/2000    
    uint32_t unixtime(void) const; // 32-bit times as seconds since 1/1/1970
protected:
    uint8_t yOff, m, d, hh, mm, ss;
};
*/

/*
typedef struct rtc_unix_t {
    uint32_t    unixtime;
    uint8_t     crc8;   // CRC8 for data EEPROM
} rtc_unix_t;
*/



// class Timer {
//     Timer();
//     
// public:
//     // This is lazily initialized. First call will always
//     // return 0. TImer overflows every ~49 days.
//     static uint32_t millis();
//     
// private:
//     uint32_t millis_impl() const;
// };

/**************************************************************************/
/*!
 *  @brief  RTC using the internal millis() clock, has to be initialized before
 * use. NOTE: this is immune to millis() rollover events.
 */
/**************************************************************************/
class RTC_Millis {
public:
    /*!
     *    @brief  Start the RTC
     *    @param dt DateTime object with the date/time to set
     */
    void begin(const DateTime &dt) { adjust(dt); }
    void adjust(const DateTime &dt);
    DateTime now();
    
protected:
    /*!
     *    Unix time from the previous call to now().
     * 
     *    This, together with `lastMillis`, defines the alignment between
     *    the `millis()` timescale and the Unix timescale. Both variables
     *    are updated on each call to now(), which prevents rollover issues.
     */
    uint32_t lastUnix;
    /*!
     *    `millis()` value corresponding `lastUnix`.
     * 
     *    Note that this is **not** the `millis()` value of the last call to
     *    now(): it's the `millis()` value corresponding to the last **full
     *    second** of Unix time preceding the last call to now().
     */
    uint32_t lastMillis;
};

/*

class RTC_Millis {
protected:
    rtc_unix_t unix_base;
    uint32_t    m_cur_ms;
    uint32_t    m_last_ms;
public:
    bool Save_EEP();
    bool Load_Unix();
    void SetDateTime(uint8_t y,uint8_t m,uint8_t d,uint8_t h,uint8_t mn,uint8_t s);
    void adjust(const DateTime& dt);
    DateTime now;
    void Update();
    void Init();
};*/


}


